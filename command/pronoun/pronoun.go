/*
When listing and removing pronoun sets their is a user-facing ID
that each role is referenced by. This ID is not stable (it could
change if new pronouns are added) and doesn't reflect the actual
role's ID. It is generated by the sort order of the actual role's
ID.

TODO:
	- if no one is using a pronoun role anymore, delete it from guild
		- seems we'll need to iterate through every member which is potentially expensive; maybe run this in the background once a day or once a week
*/
package pronoun

import (
	"fmt"
	"log"
	"regexp"
	"sort"
	"strings"

	sb "storybot"

	dgo "github.com/bwmarrin/discordgo"
)

const (
	maxPronounsPerMember = 5
	maxPronounsPerGuild  = 32
	maxPronounLength     = 16
	rolePrefix           = "pronoun: "
)

func Handler(p *sb.Params) string {
	o := p.IntData.Options[0]
	switch o.Name {
	case "add":
		return add(p)
	case "remove":
		return remove(p)
	case "list":
		return list(p)
	}
	return "No such option for pronoun command."
}

var isPronoun = regexp.MustCompile(`^[a-zA-Z] *(/ *[a-zA-Z]){0,2}$`)

func add(p *sb.Params) string {
	generalErr := "Unable to add pronoun set at this time."
	s := p.Session
	e := p.Environment
	o := p.IntData.Options[0]
	choice := o.Options[0]
	pronounSet := choice.StringValue()
	if !isPronoun.MatchString(pronounSet) {
		return "Invalid pronoun format. Please use a-z, spaces, and forward slashes, e.g. `/pronoun add they/them`. Remember, you don't have to add them all in one command â€” you can add multiple sets."
	}
	pronounSet = strings.ReplaceAll(strings.ToLower(pronounSet), " ", "")
	if strings.Count(pronounSet, "/") > 2 {
		return "Please split into multiple sets."
	}
	if len(pronounSet) > maxPronounLength {
		return fmt.Sprintf("Pronoun sets must be %d characters or less. Remember you can add multiple sets.", maxPronounLength)
	}
	roleName := rolePrefix + pronounSet
	gId := e.GuildId
	rr, err := s.GuildRoles(gId)
	if err != nil {
		log.Println(err)
		return generalErr
	}
	pronounRoleCount := 0
	for _, r := range rr {
		if strings.HasPrefix(r.Name, rolePrefix) {
			pronounRoleCount++
		}
	}
	if pronounRoleCount > maxPronounsPerGuild {
		return "Server has reached maximum number of pronoun roles. Please ping a moderator."
	}
	memberRoles := idsToRoles(rr, p.Member.Roles)
	pronounCount := 0
	for _, r := range memberRoles {
		if r.Name == roleName {
			return "You already have this pronoun set. Use `/pronoun list` to see all the pronouns you have assigned."
		}
		if strings.HasPrefix(r.Name, rolePrefix) {
			pronounCount++
		}
	}
	if pronounCount >= maxPronounsPerMember {
		return "Cannot add pronoun set. You have reached the maximum allowed."
	}
	roleId, ok := roleExists(rr, roleName)
	if !ok {
		newRole, err := s.GuildRoleCreate(gId)
		if err != nil {
			log.Println(err)
			return generalErr
		}
		_, err = s.GuildRoleEdit(gId, newRole.ID, roleName, 0, false, 0, false)
		if err != nil {
			log.Println(err)
			return generalErr
		}
		roleId = newRole.ID
	}
	if err := s.GuildMemberRoleAdd(gId, p.Member.User.ID, roleId); err != nil {
		log.Println(err)
		return generalErr
	}
	return fmt.Sprintf("Added pronouns `%s`.", pronounSet)
}

func remove(p *sb.Params) string {
	generalErr := "Unable to remove pronouns at this time."
	s := p.Session
	e := p.Environment
	o := p.IntData.Options[0]
	gId := e.GuildId
	input := o.Options[0]
	pronounId := int(input.IntValue())
	rr, err := s.GuildRoles(gId)
	if err != nil {
		log.Println(err)
		return generalErr
	}
	sort.Strings(p.Member.Roles)
	pronounCount := 0
	for _, id := range p.Member.Roles {
		r, err := sb.RoleById(rr, id)
		if err != nil {
			log.Println(err)
			return generalErr
		}
		if !strings.HasPrefix(r.Name, rolePrefix) {
			continue
		}
		pronounCount++
		if (pronounCount - 1) != pronounId {
			continue
		}
		uId := p.Member.User.ID
		if err = s.GuildMemberRoleRemove(gId, uId, id); err != nil {
			return generalErr
		}
		set := strings.SplitAfter(r.Name, rolePrefix)[1]
		return fmt.Sprintf("Removed the pronoun set `%s`", set)
	}
	return generalErr
}

func list(p *sb.Params) string {
	generalErr := "Unable to list pronouns at this time."
	rr, err := p.Session.GuildRoles(p.Environment.GuildId)
	if err != nil {
		log.Println(err)
		return generalErr
	}
	var pronouns []string
	sort.Strings(p.Member.Roles)
	pronounCount := 0
	for _, id := range p.Member.Roles {
		r, err := sb.RoleById(rr, id)
		if err != nil {
			log.Println(err)
			return generalErr
		}
		if strings.HasPrefix(r.Name, rolePrefix) {
			set := strings.SplitAfter(r.Name, rolePrefix)[1]
			ln := fmt.Sprintf("ID: %d | %s", pronounCount, set)
			pronouns = append(pronouns, ln)
			pronounCount++
		}
	}
	if len(pronouns) == 0 {
		return "You haven't assigned any pronouns yet. Use `/pronoun add [pronouns]` to add a set."
	}
	return "Your current pronouns:\n```" + strings.Join(pronouns, "\n") + "```"
}

func idsToRoles(rr []*dgo.Role, ids []string) (roles []*dgo.Role) {
	for _, id := range ids {
		for _, r := range rr {
			if r.ID == id {
				roles = append(roles, r)
			}
		}
	}
	return roles
}

func roleExists(rr []*dgo.Role, name string) (id string, ok bool) {
	for _, r := range rr {
		if r.Name == name {
			return r.ID, true
		}
	}
	return "", false
}
